#include "stm32f4xx.h" // Device header
#include "Kalman.h"

Kalman kfp;
Kalman kfp2;
/*
滤波器的反应速度太快，对噪声过于敏感，那么可以通过增大R来降低滤波器对新的观测值的敏感度，让滤波器的输出更依赖于过去的观测值。
如果你发现滤波器对系统的变化反应过慢，那么可以通过增大Q来提高滤波器的反应速度，让滤波器的输出更依赖于新的观测值。
*/
void Kalman_Init()
{
   kfp.Last_P = 1; // Last_P是滤波器上一次的误差协方差，代表估计的不确定性。初始值可以设为1，表示初始估计的不确定性较大
   kfp.Now_P = 0;  // Now_P是滤波器当前的误差协方差。因为没有开始处理数据，初始值可以设为0

   kfp.out = 0; // out是滤波器的输出值。没有开始处理数据，所以初始值可以设为0

   kfp.Kg = 0; // Kg是卡尔曼增益，用于决定新的估计值在何种程度上依赖于新的观测值和上一次的估计值。初始值设为0

   kfp.Q = 0.001; // Q越大 , 系统具有更大的不稳定性,噪声很大 , 增大会影响观测值的反应
   kfp.R = 0.05;  // R越大,滤波器的输出更依赖过去的观测值
}

void Kalman_Init2()
{
   kfp2.Last_P = 1;
   kfp2.Now_P = 0;
   kfp2.out = 0;
   kfp2.Kg = 0;
   kfp2.Q = 0.001;
   kfp2.R = 0.08;
}
/**
 *Kalman Filter
 *@param 	Kalman *kfp kalman结构体参数
 *   			float input 需要滤波参数的测量值（即传感器的采集值）
 *@return 滤波后的值(最优解)
 */
float32_t KalmanFilter(Kalman *kfp, float32_t input)
{

   kfp->Now_P = kfp->Last_P + kfp->Q;                  // 更新估计协方差
   kfp->Kg = kfp->Now_P / (kfp->Now_P + kfp->R);       // 计算卡尔曼增益
   kfp->out = kfp->out + kfp->Kg * (input - kfp->out); // 根据卡尔曼增益和观测值更新滤波器的输出值
   kfp->Last_P = (1 - kfp->Kg) * kfp->Now_P;           // 更新估计协方差
   return kfp->out;                                    // 返回滤波后的值
}

float32_t KalmanFilter2(Kalman *kfp2, float32_t input)
{
   kfp2->Now_P = kfp2->Last_P + kfp2->Q;
   kfp2->Kg = kfp2->Now_P / (kfp2->Now_P + kfp2->R);
   kfp2->out = kfp2->out + kfp2->Kg * (input - kfp2->out);
   kfp2->Last_P = (1 - kfp2->Kg) * kfp2->Now_P;
   return kfp2->out;
}

float32_t firCoeffs[Num_Taps] = {
    0.0007205184083, 0.0008038184606, 0.0009191033896, 0.001073132502, 0.001272166148,
    0.001521877595, 0.001827273285, 0.002192620421, 0.002621383406, 0.003116171574,
    0.003678694367, 0.004309730604, 0.005009107757, 0.005775691476, 0.006607390475,
    0.007501169108, 0.008453074843, 0.009458275512, 0.01051110495, 0.01160512771,
    0.0127331987, 0.01388754882, 0.01505986415, 0.01624137908, 0.01742297597,
    0.01859528385, 0.01974878833, 0.02087393589, 0.02196124196, 0.02300140262,
    0.0239854008, 0.02490460686, 0.02575087547, 0.02651664987, 0.02719503641,
    0.02777989581, 0.02826590091, 0.02864861116, 0.0289245192, 0.02909108624,
    0.02914677933, 0.02909108624, 0.0289245192, 0.02864861116, 0.02826590091,
    0.02777989581, 0.02719503641, 0.02651664987, 0.02575087547, 0.02490460686,
    0.0239854008, 0.02300140262, 0.02196124196, 0.02087393589, 0.01974878833,
    0.01859528385, 0.01742297597, 0.01624137908, 0.01505986415, 0.01388754882,
    0.0127331987, 0.01160512771, 0.01051110495, 0.009458275512, 0.008453074843,
    0.007501169108, 0.006607390475, 0.005775691476, 0.005009107757, 0.004309730604,
    0.003678694367, 0.003116171574, 0.002621383406, 0.002192620421, 0.001827273285,
    0.001521877595, 0.001272166148, 0.001073132502, 0.0009191033896, 0.0008038184606,
    0.0007205184083};

float32_t new_firCoeffs[Num_Taps] = {
    0.007205184083, 0.008038184606, 0.009191033896, 0.01073132502, 0.01272166148,
    0.01521877595, 0.01827273285, 0.02192620421, 0.02621383406, 0.03116171574,
    0.03678694367, 0.04309730604, 0.05009107757, 0.05775691476, 0.06607390475,
    0.07501169108, 0.08453074843, 0.09458275512, 0.1051110495, 0.1160512771,
    0.127331987, 0.1388754882, 0.1505986415, 0.1624137908, 0.1742297597,
    0.1859528385, 0.1974878833, 0.2087393589, 0.2196124196, 0.2300140262,
    0.239854008, 0.2490460686, 0.2575087547, 0.2651664987, 0.2719503641,
    0.2777989581, 0.2826590091, 0.2864861116, 0.289245192, 0.2909108624,
    0.2914677933, 0.2909108624, 0.289245192, 0.2864861116, 0.2826590091,
    0.2777989581, 0.2719503641, 0.2651664987, 0.2575087547, 0.2490460686,
    0.239854008, 0.2300140262, 0.2196124196, 0.2087393589, 0.1974878833,
    0.1859528385, 0.1742297597, 0.1624137908, 0.1505986415, 0.1388754882,
    0.127331987, 0.1160512771, 0.1051110495, 0.09458275512, 0.08453074843,
    0.07501169108, 0.06607390475, 0.05775691476, 0.05009107757, 0.04309730604,
    0.03678694367, 0.03116171574, 0.02621383406, 0.02192620421, 0.01827273285,
    0.01521877595, 0.01272166148, 0.01073132502, 0.009191033896, 0.008038184606,
    0.007205184083};

u16 blocksize = Block_Size;
u16 numblocks = Length_Samples / Block_Size;
float Input[Length_Samples];
float Output[Length_Samples];
float FirState_f32[Block_Size + Num_Taps - 1];

arm_fir_instance_f32 s;

void Filter(float32_t input[], float32_t output[])
{
   float32_t *inputF32, *outputF32;
   inputF32 = &input[0];
   outputF32 = &output[0];
   arm_fir_init_f32(&s, Num_Taps, (float *)&new_firCoeffs[0], &FirState_f32[0], blocksize);
   // arm_fir_init_f32(&s,Num_Taps,(float *)&firCoeffs[0],&FirState_f32[0],blocksize);
   for (u16 i = 0; i < numblocks; i++)
   {
      arm_fir_f32(&s, inputF32 + (i * blocksize), outputF32 + (i * blocksize), blocksize);
   }
}

#define N 10 // 滑动窗口的大小
float buffer[N] = {0};
int index = 0;

/*
滑动平均滤波器,主要适用于减小随机噪声。
*/
float moving_average(float input)
{
   buffer[index++] = input;
   if (index >= N)
      index = 0;
   float sum = 0;
   for (int i = 0; i < N; i++)
      sum += buffer[i];
   return sum / N;
}

#define ALPHA 0.1 // 滤波器的权重因子

/*
指数移动平均滤波器，主要适用于减小随机噪声，并能够适应数据的变化趋势。
*/
float exponential_moving_average(float input)
{
   static float output = 0;
   output = ALPHA * input + (1.0 - ALPHA) * output;
   return output;
}
